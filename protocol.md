# Протокол связи мобильного приложения с замками BuyQawHome

## Канал связи

Канал связи между замками и смартфоном: BLE (Bluetooth 4.0+)

Необходимо проверять есть ли BLE на устройстве - если нет, то отключается весь этот функционал.

### Что такое BLE и с чем его есть

BLE - Bluetooth Low Energy - новый протокол bluetooth связи, поддерживаемый адаптерами выше 4.0.  
В теорию не надо входить, даллее более простая версия для понимания.

#### Маяк

Периферия (далее маяк) - BLE устройство, которое раздает данные, является сервером в этой топологии. 

1. Оно создает
сервисы (Services), которые по сути можно назвать страницами, если по аналогии с вэб технологиями. У каждого сервиса есть
свой уникальный hex номер UUID в виде "fa6c07ce-2291-44d6-bdf6-1801707609aa", который как бы является его URL. 
2. Далее внутри
каждого сервиса есть характеристики, которые по сути являются div-ами, опять таки по аналогии. И как div в HTML имеют свои id,
характеристики имеют свои UUID в виде "fa6c07ce-2291-44d6-bdf6-1801707609aa", отличные от UUID сервиса. И точно так же как
и div, они могут быть разными, какие-то просто выводят информацию (READ), какие-то могут записывать (WRITE), какие действуют
по типу aler() в javascript (NOTIFY). 

Пример периферии:

1. Бананы от яблока
2. Маяки местоположения для внутренней навигации
3. Часики от сяоми

*ВАЖНО*: сервер может одновременно работать только с одним клиентом, а клиент может подключаться к нескольким серверам.

#### Считыватель

Центр (далее считыватель) - BLE устройство, которое подключается к маяку и получает информацию, как бы клиент сервера.

1. Оно подключается к маяку и проводит манипуляции с сервисами и характеристиками.

Пример центра:

1. Смартфон

## Как работает замок BuyQaw и что должно делать приложение

1. На смартфоне создается и на заднем фоне постоянно работает маяк (BLE peripheral) с определенными значениями, которые будут ниже.
2. Когда человек со смартфоном подходит к замку, замок подключается к маяку и пишет свой MAC adress.
3. Смартфон ищет в памяти пароль доступа к замку. (или отправляет запрос на веб сервер системы и тянет ключь оттуда)
4. Смартфон проводит процесс "Идентификация" и замок открывает дверь.
5. Замок дает знать, что открыл дверь по процессу "Ясен пень".
6. Смартфон отправляет данные на сервер, что зашел.

### Характеристики маяка

У маяка должны быть следующие сервисы и характеристики, чтобы замок начал с ним работу:

```C++
// UUID сервиса (можно выставлять только 4 значения, остальные адаптер заполнит сам)
#define SERVICE_UUID        "BA10"

// UUID характеристик
#define CHECK_UUID          "BA52" // Проверка          [WRITE]
#define PASSWD_PORT_UUID    "BA44" // Пароль            [NOTIFY]
#define ADMIN_PORT_UUID     "BA13" // Админ панель      [NOTIFY]
#define ACTION_PORT_UUID    "BA87" // Действия          [NOTIFY]
#define INCOMING_PORT_UUID  "BA76" // Прием             [WRITE]
#define FILLER_0            "BA66" // Отвлекающий       [NOTIFY]
#define FILLER_1            "BA91" // маневр, эти       [NOTIFY]
#define FILLER_2            "BA01" // характеристики    [WRITE]
#define FILLER_3            "BA28" // ничего не делают. [NOTIFY]
```

### Алгоритм, протокол

Все общение смартфона с замком через BLE в виде строк ASCII.

1. Замок подключается к маяку и отправляет свой MAC адрес в характеристику Проверка в виде ASCII текста.
2. Смартфон ищет в памяти пароль доступа к замку. (или отправляет запрос на веб сервер системы и тянет ключь оттуда)
и отправляет его с помощью уведомления на характеристику Пароль в виде ASCII текста.
3. Замок отправляет 1 на характеристику Прием, если пароль подходит, или 0, если нет.
4. Если пароль был из памяти смартфона, то смартфон отправляет запрос на веб сервер системы и тянет ключь оттуда. Возврат на 2.
5. Если пароль не подходит - доступа нет.
6. Если пароль подходит, то смартфон отправляет через уведомление с порта Действия 1 в виде ASCII текста.
7. Замок отправляет 1 в характеристику Прием, когда открывается.
8. Смартфон отключает замок, обнуляет все значения в характеристиках и отправляет данные на сервер.

## Примеры и мануалы

Далее приведу несколько примеров.

### Android

1. [Тут пример](https://code.tutsplus.com/tutorials/how-to-advertise-android-as-a-bluetooth-le-peripheral--cms-25426)
2. [Тут еще один](https://thejeshgn.com/2016/12/11/uart-gatt-server-peripheral-on-android/)

### iOS

1. [И теория и практика](https://codeburst.io/getting-started-with-bluetooth-low-energy-on-ios-ada3090fc9cc)
2. [На русском](https://habr.com/ru/post/425937/)

### Теория, которая Вам не нужна, товарищ

1. [English](https://www.oreilly.com/library/view/getting-started-with/9781491900550/ch01.html)
2. [Русский](https://habr.com/ru/post/319244/)

# Протокол связи мобильного приложения с сервером по системе "BuyQawHome"

## Канал связи

Канал связи приложения с сервером - TCP Socket. Данный метод проверен временем, устойчив и популярен. Что еще важно,
он поддерживает возможность шифрования, но это уже в будущем.

* ВАЖНО *: кодировка должна быть UTF-8, по стандарту TCP Socket использует ASCII, но можно и поменять кодировку. 
На бэке энкодинг будет проходить из UTF-8.

### Пример работы

Автор читайменя не специалист в мобильной разработке.

#### Android

1. Вот [тут](https://github.com/dombrock-archive/TCPz-Android) парень замутил простейший TCP клиент.
2. Вот [тут](https://stackoverflow.com/questions/35172856/send-unicode-string-to-server-socket) работа с UTF-8 в сокетах,
но трабл был в сервере на стаке, а сам код пашет.

#### iOs

1. Вот [тут](https://github.com/swiftsocket/SwiftSocket) swift библиотека для работы с сокетами.
2. Вот [тут](https://www.raywenderlich.com/537-real-time-communication-with-streams-tutorial-for-ios) пример-мануал.
3. Вот [тут](http://qaru.site/questions/607677/ios-simple-tcp-connection-example/2435630#2435630) как работать с UTF-8.

## Формулировка сообщений

Сообщения между сервером и приложением имеют следующий вид:

```javascript
r/o;56303h43;930423;[{"name":: "Зеленый Квартал", "id": "Some ID", "enter": [{"name":: "1A", "ttl": "1555666261"}]}];BIClients
```

### Контроль

Первая буква, которая определяет вид сообщения и действий по отношению к нему. За ней всегда следует "/".

1. r - Регистрация нового пользователя.
2. a - Получение данных от считывателя.
3. g - Приглашение гостя.
4. d - удаление или изменение прав доступа гостя.
5. e - Успешное изменение пароля доступа.
6. x - создание новой двери

Функционал 3-5 будет реализован в следующих итерациях. Сейчас фокусировка на 1-2.


### Источник

Источник определяет откуда пришла информация:

1. BIClients - из приложения BIClients
2. Genuine - из собственного приложения


### Данные

#### Регистрация пользователей

При регистрации нового пользователя, приложение создает подключение к серверу и отправляет сообщение регистрации. 
Но сообщение регистрации также отправляется при истечении времени жизни ключа доступа к двери.  

Тело сообщения:

1. Приложение: ```r/o;56303h43;930423;[{"name": "Зеленый Квартал", "id": "Some ID", "enter": [{"name": "1A"}]}];BIClients```
2. Сервер: ```r/o;56303h43;930423;[{"name":: "Зеленый Квартал", "id": "Some ID", "enter": [{"name":: "1A", "ttl": "1555666261", "key": "123456"}]}];BIClients```

##### Расшифровка сообщений

1. r/ - Контроль - регистрация
2. o; - Тип пользователя: o - владелец, s - сожитель (доверенное лицо), g - гость
3. ```56303h43;``` - ID пользователя
4. ```930423;``` - Первые 6 цифр ИИН
5. ```[{"name":: "Зеленый Квартал", "id": "Some ID", "enter": [{"name":: "1A"}]}];``` - Массив словарей с доступными для жителя подъездами, "name": - Имя ЖК, ID - Идентификационный номер, enter - массив словарей с подъездами, где: "name": - имя входа (первый подъезд или шлагбаум в паркинг). Почему массив словарей? Возможность легко масштабировать данные.
6. BIClients - Источник 

Ответ сервера совпадает с сообщением, но там еще указывается TTL - time to live (timestamp в секундах) и ключь доступа (о нем 
поговорим ниже в главе получение доступа), то есть до какого времени 
можно хранить эти ключи в памяти телефона. По истечению TTL необходимо отправить сообщение регистрации, и тогда сервер
обновит пароли и TTL.

#### Получение данных от считывателя

В момент получения МАК адреса от считывателя, приложение делает следующее:

1. Ищет в памяти ключь доступа и отдает его по алгоритму "Открытие", отправляет сообщение 3
2. Если нет ключа в памяти - обращается на сервер за разрешением


1. Приложение: ``` a/?56303h43;80:e6:50:02:a3:9a; ``` 
2. Сервер | ```a/123456;1555666261;``` 
3. Приложение: ```a/!56303h43;80:e6:50:02:a3:9a;1555666261;``` 
4. Сервер: ```a/!``` 

##### Расшифровка сообщений

1. a/ - контроль, ? - запрос, 56303h43; - ID пользователя, 80:e6:50:02:a3:9a; - МАК адрес замка
2. a/ - контроль, 123456; - ключь доступа, 1555666261; - TTL ключа
3. a/ - контроль, ! - утверждение, 56303h43; - ID пользователя, 80:e6:50:02:a3:9a; - МАК адрес замка, 1555666261; - время входа
4. Принятие запроса
